% Data 

## Introduction 



## Libraries

Packages needed for the nalysis are loaded. If the libraries do not exist locally, they will be downloaded.  
```{r message=FALSE, warning=FALSE}
list.of.packages <-
  c(
    "tidyverse",
    "data.table",
    "ggplot2",
    "knitr",
    "zoo",
    "RCurl",
    "imputeTS",
    "scales",
    "padr",
    "readxl",
    "stringr",
    "lubridate",
    "readr",
    "egg"
  )

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]

#Download packages that are not already present
if(length(new.packages)) install.packages(new.packages)

packages_load <-lapply(list.of.packages, require, character.only = TRUE)

#Print warning if there is a problem with installing/loading some of packages
if (any(as.numeric(packages_load)==0)){
  warning(paste("Package/s", paste(list.of.packages[packages_load != TRUE]), "not loaded!"))
}else {
  print("All packags are succesfully loaded")
}

rm(list.of.packages, new.packages)

```


## Data 

### Weather Data
Historical weather data from a Met Ã‰ireann Oak Park synoptic weather station was used for model evaluation. The trial sites were in the radius of up to 500 m from the station in all years. 

```{r message=FALSE, warning=FALSE}
#Weather data, parameters and cut off dates
load(file="data/OP_2007-2016.RData")
OP[1:5,1:20]
```


```{r}
colnames(OP)[which(names(OP) == "year")] <- "year_var"
OP <- add_column(OP, week_var =data.table::week(OP$date), .before = "i_rain" )
OP <- add_column(OP, doy = data.table::yday(OP$date), .before = "i_rain" )
```
Subset the data to exclude the months of the year which we do not need for the analysis. 
```{r}
OP <- subset(OP, month >3 & month < 10)
```
Remove the variables we dont need for the analysis, to make some speed gains. 



Get summary of missing values for the variables of interest. 
```{r}
OP %>% group_by( year_var)  %>%
  summarize(NA_rain = sum(is.na(rain)),
            NA_temp = sum(is.na(temp)),
            NA_rhum = sum(is.na(rhum)))
```

Missing value imputation with qbic spline function works well up to 8 consecutive values, for variables that have some seasonal frequency, temperature and relative humidity in our case. 

```{r message=FALSE, warning=FALSE}
infil_gap <- 8 #Maximum length of the infill gap
OP$temp <- round(na.spline(OP$temp, na.rm = FALSE, maxgap = infil_gap),1)
OP$rhum <- round(na.spline(OP$rhum, na.rm = FALSE, maxgap = infil_gap),0)
OP$rhum  <- sapply(OP$rhum, function(x) ifelse(x>100, x<-100, x))
#Check if the imputation worked
OP %>% group_by( year_var)  %>%
  summarize(NA_rain = sum(is.na(rain)),
            NA_temp = sum(is.na(temp)),
            NA_rhum = sum(is.na(rhum)))
```

Rain is somewhat harder to impute but there are ways around this problem, especially when there is only few values missing. Since rain data is required only in certain rare situations, which are defined within the model, we can use the same conditions to impute these missing values. 
We are certain that rain is irelevant if relative humidity is below 88% and temperature of 8C, and these values can then be replaced with 0. 

```{r}
OP[is.na(OP$rain),]$rain<- with(OP[is.na(OP$rain),],ifelse(rhum<88|temp<8, 0, rain))
OP %>% group_by( year_var)  %>%
  summarize(NA_rain = sum(is.na(rain)),
            NA_temp = sum(is.na(temp)),
            NA_rhum = sum(is.na(rhum)))
```


## The analysis 

The set of main parameters of Irish rules model is evaluated. The csv sheet with parameters under evaluation is avaialbe in data folder and can be changed and used for model evaluation in other locations. Coulnd named `risk_11111` represents set of the original model parameters. 

```{r message=FALSE, warning=FALSE}
#read in parameters
par <- read_csv(paste0("./data/parameters.csv"), skip = 10)
par$param_set <-stringi::stri_replace_all_fixed(par$param_set, "\t", "")
par
```
###The model
Implementation of the model
```{r}
IrishRulesModel <-function(data, param = NULL){
  # Parameter list
  if (is.null(param)){
    rh_thresh <- 90
    temp_thres <- 10
    hours <- 12   #sum of hours before EBH accumulation
    wet_before <- 3
    wet_after <- 3
  }else{
    #pass a vector of parameters 
    rh_thresh <- as.numeric(param[2])
    temp_thres <- as.numeric(param[3])
    hours <- as.numeric(param[4])   
    wet_before <- as.numeric(param[5])
    wet_after <- as.numeric(param[6])
    lw_rhum <- param[7]           #if is NA then only rain data will be used
  }
  
  data  %>% collect  %>% .[["rain"]] -> rain
  data  %>% collect  %>% .[["rhum"]] -> rh
  data  %>% collect  %>% .[["temp"]] -> temp
  if(sum(is.na(with(data, rain, temp,rhum)))>5){
    stop(print("sum of NAs is more than 5"))
  }
  
  #"Out of boounds"
  rain <- c(rain, rep(0,20))
  temp <- c(temp, rep(0,20))
  rh <- c(rh, rep(0,20))
  
  rain <- na.approx(rain, maxgap = 5)
  temp <- na.approx(temp, maxgap = 5)
  rh <- na.approx(rh, maxgap = 5)
  # rain <- as.vector(data[,9])
  # temp <- data[,6]
  # rh <- data[,7]
  # class(temp)
  # check if there is 12 hours of conditions: rh >= 90 and t>= 10
  criteria<- as.numeric(temp>=temp_thres & rh>=rh_thresh) #Specify criteria> data$crit
  
  #cumulative sum with restart at zero
  #criteria_sum <-  ave(criteria, cumsum(criteria == 0), FUN = cumsum)
  #data$rs33 <- with(rle(data$rs1!=0), sequence(lengths)*rep(values, lengths))
  criteria_sum <- ave(coalesce(criteria, 0), data.table::rleid(zoo::na.locf(criteria != 0,maxgap = 3)), FUN = cumsum)
  
  
  #cumulative sum with restart at zero
  # criteria_sum <-  ave(criteria, cumsum(criteria == 0), FUN = cumsum)
  #data$rs33 <- with(rle(data$rs1!=0), sequence(lengths)*rep(values, lengths))
  risk <- rep(0, length(temp))
  
  criteria_met12  <-as.numeric( criteria_sum >= hours )
  idx             <-which(criteria_sum == hours)
  
  
  #If there are no accumulations return vector with zeros
  if (sum(criteria_sum == hours)==0){                #breaks the loop if there is no initial accumulation of 12 hours
    head(risk,-20)
    } else{
        for (j in 1 : length(idx)){   
       
          #switch that looks if there was wetness: first rain, then both rain and rh, if rh exists
          if(if (is.na(lw_rhum)){                                            #if thee is no input for rhum threshold
            (sum(rain[(idx[j]-wet_before):(idx[j]+wet_after)])>= 0.1)           #just see rain sum
          }else{
            any((any(rh[(idx[j]-wet_before):(idx[j]+wet_after)]>= lw_rhum)) |   #take both as possible switches
                (sum(rain[(idx[j]-wet_before):(idx[j]+wet_after)])>= 0.1))   
          }) # outputs true or false
          {         
            n <- idx[j]        #start accumulation from 12th hour
          } else {         
            n <- idx[j]+4      #start accumulation from 16th hour
          }    
          s <- criteria_met12[n]
          # if a break of less than or equal to 5 hours  
          m <- n-1;
          while (s==1)
          { 
            risk[n] <- risk[m]+1  
            n <- n+1;
            m <- n-1;
            s <- criteria[n] 
            if ( s==0 && (criteria[n+2]==1)) {
              n = n+2;
              s=1;
            } else if ( s==0 && (criteria[n+3]==1)) {
              n = n+3;
              s=1;
            } else if ( s==0 && (criteria[n+4]==1)) {
              n = n+4;
              s=1;
            } else if( s==0 && (criteria[n+5]==1)) {
              n = n+5;
              s=1;
            }      
          }  
          
      }   
      head(risk,-20) #remove last 20 values that were added to vectors to prevent "Out of bounds" issue
    
    }
  
}
```


###Model Run
The model is run for each set of parameters, and columns with model outputs are attached to weather data frame. Names of new columns corespond to the set of parameters supplied. 
```{r}
#data frame split by year and dynamicly added columns as result of model run with different parameters
#save the output of function as name of curent run in new column

for(i in 1:nrow(par) ){
  loop_var <- apply(par[i,],1, function(x) {
    k <- lapply(split(OP, factor(OP$year)), function(chunk)  IrishRulesModel(chunk, x)) #get the list of outpus
    unlist(k) -> k  #make it a vector
  })
  OP[,ncol(OP)+1] <-  as.numeric(loop_var)
  rm(loop_var)
  names(OP)[ncol(OP)] <- paste0(par[i,1])
}

nn <- paste0(names(OP[,26:73]), "_ebh","")
names(OP[,26:73]) <-  nn
setnames(OP, old = c(names(OP[,26:73])), new = nn)
rm(i,nn)
# Sample of outputs
head(OP[, c(1,7,9,15,24:30)],5)
```

## Description of variables

- Variable1: 
  - Description 
  - Type: character
  - Unit

- Variable2: 
  - Description 
  - Type: integer
  - Unit

- Variable3: 
  - Description 
  - Type: double
  - Unit:
  
## Quick view 

```{r}
data
```


## Download 

The data are deposited in xx public repositories where they can be downloaded. Check on each data repository the policies regarding data use and citation.

<img src = "https://osf.io/static/img/circle_logo.png" width = "25">
[](DOI 10.17605/OSF.IO/7D3CH) 



